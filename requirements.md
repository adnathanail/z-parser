 - [x] §1 You are to build a lexer and a parser for Z˜.
 - [x] §2 A Z˜ program is a list of declarations or definitions for global variables, data types, and functions. This list cannot be empty: it must ends with a definition for the special main function. The execution of a Z˜ program starts from main.
 - [x] §3 An identifier in Z˜ starts with a letter, followed by an arbitrary number of underscores, letters, or digits. Identifiers are case-sensitive. Punctuation other than underscore is not allowed.
 - [x] §4 Table 1 defines Z˜’s builtin data types. A boolean value is either T (true) or F (false) and has type bool. T and F cannot be used as identifiers.
 - [x] §5 Numbers are integers (type int), rationals (type rat), or floats (type float). Negative numbers are represented by the ‘-’ symbol before the digits. Examples of integers include 1 and -1234; examples of rationals include 1/3 and -345_11/3; examples of floats are -0.1 and 3.14.
 - [x] §6 A character is a single letter, punctuation symbol, or digit wrapped in ’’ and has type char. The allowed punctuation symbols are space (See http://en.wikipedia.org/wiki/Punctuation) and the ASCII symbols, other than digits, on this page http://www.kerryr.net/pioneers/ascii3.htm.
 - [x] §7 Sequences (type seq) are ordered containers of elements. Its declaration must specify the type of its elements. For instance, seq<int> l := [1,2,3], and seq<char> s := [’f’, ’o’, ’o’]. You can use the top keyword to specify a sequence that contains any type, writing seq<top> s := [ 1, 1/2, 3.14,[ ’f’, ’o’, ’u’, ’r’] ]. Sequences have nonnegative length. Applying the built-in operator len to a sequence s returns its length. The empty list is [].
 - [x] §8 Strings (type str) are sequences of characters that Z˜ natively defines. String literals are syntactic sugar for character sequences and are wrapped in "", so "abc" is [ ’a’, ’b’, ’c’].
 - [x] §9 Z˜ sequences support the standard indexing syntax and the indices of s range from 0 to len(s)-1. The expression s[i] returns the element in s at i. For the string s := "hello world", s[len(s)-1] returns ‘d’.
 - [x] §10 Sequences in Z˜ also support slicing: s[i:j] returns another sequence that is a subsequence of s starting at s[i] and ending at s[j-1]. Given a := [1,2,3,4,5], a[1:3] is [2,3]. When the start index is not given, the slice starts from index 0 of the original sequence (e.g., a[:2] is [1,2]). Similarly, when the end index is not given, the slice ends with the last element of the original sequence (e.g., a[3:] is [4,5]). Finally, indices can be negative, in which case its value is determined by counting backwards from the end of the original sequence: a[2:-1] is equivalent to a[2:len(a)-1] and, therefore, is [3,4,5], while s[-2] is 4. The lower index in a slice must be positive and smaller than the upper index, after the upper index has been subtracted from the sequences length if it was negative.
 - [x] §11 Z˜ supports Python-like list comprehensions. A list comprehension is surrounded by square brackets and uses the builtin range function. They have the form [x * 2 for x of range(10)] where for and of are keywords. range is a function that generates an integer sequence. It can take up to three arguments, but must be called with at least one. These arguments are either integer literals, or variables, with the first argument being the starting point, the second the terminating point, and the third the increment. This is similar to the range function in Python. range(10) builds an integer sequence starting from 0; range(1, 10) builds from 1; and range(1, 20, step) builds a list from 1 to 20 in increments of step, a user-defined variable. An optional boolean valued filter, starting with if, can also be used [x * 3 for x of range(100), if x / 2 = 5]. The if expression must follow a comma.
 - [x] §12 Dictionaries (type dict) are collections of (key, value) pairs. When declaring a dictionary, one must specify the type of its keys and values. For example, for dict<int,char> d, the keys are integers and the values, characters. Use top to define a dictionary that allows any type of keys or values: dict<int,top> d := (1:1, 2:’c’, 7:3/5, (1:T)). An empty dictionary is (). The assignment d[k] := v binds k to v in d. If d already contains k, k is rebound to v; if not, the pair (k, v) is added to d and accessed by d[k]. For a dictionary, the operator len returns the number of (key, value) pairs. The operator + concatenates two dictionaries, reporting an error when they share a key.
 - [x] §13 Applications of the operators listed in Table 2 result in expressions. Table 3 exemplifies Z˜ expressions. Specifically, “!” denotes logical not, “&&” logical and, and “||” logical or, as is typical in the C language family. In Z˜, “=” is referential equality and “:=” is the assignment operator. The ? operator checks whether a key is present in a dictionary, as in 2 ? (1:"one", 2:"two"), and returns a boolean. The “+” operator over sequences denotes concatenation. Field accesses are expressions and have the syntax id.field. Parentheses “()” enforce precedence.
 - [x] §14 Function calls are expressions. The actual parameters of function calls are also expressions that, in the semantic phase (i.e. not this coursework), would be required to produce a type that can unify with the type of their parameter.
 - [x] §15 The syntax of variable declaration is “type id;”. Variables may be initialised at the time of declaration: “type id := exp;”.
 - [x] §16 A data type definition is `tdef type_id { declaration_list } ;` where declaration_list is a comma-separated list of variable declarations. These variables are called fields. For newly defined types, initialisation consists of a sequence of comma-separated values, each of which is assigned to the data type fields in the order of declaration. Listing 3 contains examples.
 - [x] §17 For readability, Z˜ supports type aliasing: the statement “alias old_name new_name;” allows using new_name in place of old_name.
 - [x] §18 Listing 2 shows the syntax of function definitions in Z˜. Specifically, a function’s name is an identifier. The formal_parameter_list separates parameter declarations, which follow the variable declaration syntax type id, with commas. A function’s body cannot be empty; it starts with declarations or definitions for local variables, followed by other statements. The return type of a function, return_type, can be omitted when the function does not return a value. The main function does not return a value; that is, return statements in main cannot have a value.
 - [x] §19 In Table 4, var indicates a variable. An expression_list is a comma-separated list of expressions. As above, a body consists of local variable declarations (if any), followed by statements. Statements, apart from if-else and while, terminate with a semicolon. The return statement appears in a function body and is optional. In any if statement, there can be zero or one else branch.
 - [x] §20 The statement read var_id; reads a value from the standard input and stores it in var_id; the statement print exp; prints evaluation of exp, followed by a newline.
 - [x] §21 The if statement behaves like that in the C family language. In any if statement, there can be zero or more elif branches, followed by either zero or one else branch.
 - [x] §22 The unguarded while statement is the only explicit loop construct in Z˜. To exit a loop, one must use break N, usually coupled with an if statement; the optional argument N is a positive integer that specifies the number of nested loops to exit and defaults to 1. The use of break statement is forbidden outside a loop. Listing 4 shows how to use while and break.
 - [x] §23 Z˜ enables multithreading through the thread type. You must associate a block of code with each thread variable at declaration. When control reaches a thread declaration, a new thread is created to start executing the code in the associated block; the original thread returns from this assignment immediately and resumes execution with the next statement. You may call the built-in function wait to wait for a particular thread to finish. The calling thread will block until the parameter thread is finished. Listing 5 creates two threads, t1 and t2, each of which will print a sentence before the main thread terminates.
 - [x] §24 Listing 6 shows an example program in Z˜: it defines a function to reverse a sequence.
 - [x] §25 Your parser will be tested against a test suite of public test cases provided via Moodle and private ones. This testing is scripted; so it is important for your output to match what the script expects.
 - [x] §26 The test cases include positive tests, on which your parser must emit "Parsing successful." followed by a newline and nothing else, and negative tests on which your parser must emit the correct line and column of the error.
 - [x] §27 The provided SC class uses a boolean field syntaxErrors of the parser object to decide whether parsing is successful. So please find such a public field in the Parser class and set it to true when a syntax error is generated.
 - [x] §28 Your scanner (lexer) must
   - Use JFlex (or JFlex) to automatically generate a scanner for the Z˜ language;
   - Make use of macro definitions where necessary. Choose meaningful token type names to make your specification readable and understandable;
   - Ignore whitespace and comments; and
   - Report the line and the column (offset into the line) where an error, usually unexpected input, first occurred. Section 3 specifies the format that will be matched by the grading script.
 - [x] §29 Your parser must
   - Use CUP to automatically produce a parser for the Z˜ language;
   - Resolve ambiguities in expressions using the precedence and associativity rules;
   - Print “Parsing successful.”, followed by a newline, if the program is syntactically correct.
