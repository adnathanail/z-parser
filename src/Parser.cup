import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  static class ErrorInfo {
    public int line;
    public int column;

    public ErrorInfo(int line, int column) {
      this.line = line;
      this.column = column;
    }
  }

  static class Node {
      public ArrayList<Node> children;
      private static int globalCounter = 0;

      public int counter;
      private Object value;

      public Node(Object value){
        Node.globalCounter += 1;
        this.counter = Node.globalCounter;
        this.value = value;
        this.children = new ArrayList<Node>();
      }

      public void addChild(Node n){ children.add(n); }

      public String toString(){
        String ret = "";
        ret += String.format("%d [label=\"%s\"];\n",
                              counter, value.toString());
        for(Node n: children){
          ret += String.format("%d -> %d;\n", this.counter, n.counter);
          ret += n.toString();
        }
        return ret;
      }
    }

  Lexer lexer;

  // used by SC.java to decide whether parsing is successful
  public boolean syntaxErrors;

  public Parser(Lexer lex) {
      super(lex);
      lexer = lex;
  }

  public void syntax_error(Symbol cur_token) {
    this.syntaxErrors = true;
  }

  public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
    this.syntaxErrors = true;
    report_fatal_error(
      "Syntax error at line " + (cur_token.left+1) + ", column "
      + cur_token.right + ".\n", null
    );
  }

  public void custom_err_report(String message, int line, int column)
    throws java.lang.Exception
  {
    this.syntaxErrors = true;
    report_fatal_error( message + "\n", new ErrorInfo(line, column) );
  }

:};

terminal ILLEGAL_CHARACTER, FDEF, MAIN, LPAREN, RPAREN, LCURL, RCURL, SEMICOL, PRINT, STRING, PRIMTYPE, IDENTIFIER, ASSIGN, INTEGER, CHAR, RETURN, FLOAT, RATIONAL, SEQ, RANGLE, LANGLE, LSQUARE, RSQUARE, COMMA, PLUS;

nonterminal program, statements, statement, value, datatype, sequence, sequence_items, functions, function, parameters, parameter_items, number, main, argument_items, arguments;

precedence left PLUS;

program ::= functions:fs main:m {:
        Node n = new Node("PROGRAM");
        n.addChild((Node)fs);
        n.addChild((Node)m);

        // System.out.println("digraph G {");
        // System.out.println(n);
        // System.out.println("}");

        RESULT = n;
    :};

/* TODO prevent main having return values */
main ::=
    FDEF MAIN LPAREN RPAREN LCURL statements:ss RCURL SEMICOL {:
        Node n = new Node("MAIN");
        n.addChild((Node)ss);
        RESULT = n;
    :};

functions ::=
    /* empty */ {: RESULT = new Node("FUNCTIONS"); :} |
    functions:fs function:f {:
        Node n = (Node)fs;
        n.addChild((Node)f);
        RESULT = n;
    :};

function ::= FDEF datatype:dt IDENTIFIER:i parameters:ps LCURL statements:ss RCURL SEMICOL {:
        Node n = new Node("FUNCTION");
        n.addChild((Node)dt);
        n.addChild((Node)ps);
        n.addChild((Node)ss);
        RESULT = n;
    :};

parameters ::= LPAREN parameter_items:pis RPAREN {: RESULT = pis; :};

parameter_items ::=
    /* empty */ {: RESULT = new Node("PARAMETERS"); :} |
    datatype:dt value:v {:
        Node n = new Node("PARAMETERS");
        n.addChild((Node)dt);
        n.addChild((Node)v);
        RESULT = n;
    :} |
    parameter_items:pis COMMA datatype:dt value:v {:
        Node n = (Node)pis;
        n.addChild((Node)dt);
        n.addChild((Node)v);
        RESULT = n;
    :};

arguments ::= LPAREN argument_items:ais RPAREN {: RESULT = ais; :};

argument_items ::=
    /* empty */ {: RESULT = new Node("ARGUMENTS"); :} |
    value:v {:
        Node n = new Node("ARGUMENTS");
        n.addChild((Node)v);
        RESULT = n;
    :} |
    argument_items:ais COMMA value:v {:
        Node n = (Node)ais;
        n.addChild((Node)v);
        RESULT = n;
    :};

statements ::=
    statements:ss statement:s SEMICOL {:
        Node n = (Node)ss;
        n.addChild((Node)s);
        RESULT = n;
    :} |
    /* empty */ {:
        RESULT = new Node("STATEMENTS");
    :};

statement ::=
    PRINT STRING:s {:
        Node n = new Node("PRINT");
        n.addChild(new Node(s));
        RESULT = n;
    :} |
    datatype:dt IDENTIFIER:id {:
        Node n = new Node("DECLARATION");
        n.addChild((Node)dt);
        n.addChild(new Node(id));
        RESULT = n;
    :} |
    datatype:dt IDENTIFIER:id ASSIGN value:v {:
        Node n = new Node("ASSIGNMENT");
        n.addChild((Node)dt);
        n.addChild(new Node(id));
        n.addChild((Node)v);
        RESULT = n;
    :} |
    RETURN {: RESULT = new Node("RETURN"); :} |
    RETURN value:v {:
        Node n = new Node("RETURN");
        n.addChild((Node)v);
        RESULT = n;
    :};

datatype ::=
    PRIMTYPE:dt {: RESULT = new Node(dt); :} |
    SEQ LANGLE datatype:dt RANGLE {:
        Node n = new Node("SEQUENCE");
        n.addChild((Node)dt);
        RESULT = n;
    :};

sequence ::= LSQUARE sequence_items:sis RSQUARE {: RESULT = sis; :};

sequence_items ::=
    /* empty */ {: RESULT = new Node("SEQUENCE"); :} |
    value:v {:
        Node n = new Node("SEQUENCE");
        n.addChild((Node)v);
        RESULT = n;
    :} |
    sequence_items:sis COMMA value:v {:
        Node n = (Node)sis;
        n.addChild((Node)v);
        RESULT = n;
    :};

value ::=
    value:v1 PLUS value:v2 {:
        Node n = new Node("PLUS");
        n.addChild((Node)v1);
        n.addChild((Node)v2);
        RESULT = n;
    :} |
    IDENTIFIER:i arguments:as {:
        Node n = new Node("FUNCTION CALL");
        n.addChild(new Node(i));
        n.addChild((Node)as);
        RESULT = n;
    :} |
    INTEGER:i    {: RESULT = new Node(i); :} |
    FLOAT:f      {: RESULT = new Node(f); :} |
    RATIONAL:r   {: RESULT = new Node(r); :} |
    CHAR:c       {: RESULT = new Node(c); :} |
    IDENTIFIER:i {: RESULT = new Node(i); :} |
    number:n     {: RESULT = new Node(n); :} |
    sequence:s   {: RESULT = s; :};
