import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  static class ErrorInfo {
    public int line;
    public int column;

    public ErrorInfo(int line, int column) {
      this.line = line;
      this.column = column;
    }
  }

  static class Node {
      public ArrayList<Node> children;
      private static int globalCounter = 0;

      public int counter;
      private Object value;

      public Node(Object value){
        Node.globalCounter += 1;
        this.counter = Node.globalCounter;
        this.value = value;
        this.children = new ArrayList<Node>();
      }

      public void addChild(Node n){ children.add(n); }

      public String toString(){
        String ret = "";
        ret += String.format("%d [label=\"%s\"];\n",
                              counter, value.toString());
        for(Node n: children){
          ret += String.format("%d -> %d;\n", this.counter, n.counter);
          ret += n.toString();
        }
        return ret;
      }
    }

  Lexer lexer;

  // used by SC.java to decide whether parsing is successful
  public boolean syntaxErrors;

  public Parser(Lexer lex) {
      super(lex);
      lexer = lex;
  }

  public void syntax_error(Symbol cur_token) {
    this.syntaxErrors = true;
  }

  public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
    this.syntaxErrors = true;
    report_fatal_error(
      "Syntax error at line " + (cur_token.left+1) + ", column "
      + cur_token.right + ".\n", null
    );
  }

  public void custom_err_report(String message, int line, int column)
    throws java.lang.Exception
  {
    this.syntaxErrors = true;
    report_fatal_error( message + "\n", new ErrorInfo(line, column) );
  }

:};

terminal INTEGER, PLUS, MULT, ILLEGAL_CHARACTER;

nonterminal expr, term, factor;

precedence left PLUS, MULT;

expr ::= expr:e PLUS term:t {:
           Node n = new Node("PLUS");
           n.addChild(new Node(e));
           n.addChild(new Node(t));
           RESULT = n;
       :}
       | term:t {: RESULT = new Node(t); :}
       ;

term ::= term:t MULT factor:f {:
           Node n = new Node("MULT");
           n.addChild(new Node(t));
           n.addChild(new Node(f));
           RESULT = n;
       :}
       | factor:f {: RESULT = new Node(f); :}
       ;

factor ::= INTEGER:i {: RESULT = new Node(i); :};